import csv
import matplotlib.pyplot as plt

# Initializing string arrays for titles, legends, names of files generated by layering.py, etc.
data = []
titles = ['Equal', 'Uniform', 'Normal']
subtitles = ['Non-perturbed', 'Perturbed']
methods = ['equal', 'equal_perturbed', 'uniform','uniform_perturbed', 'normal', 'normal_perturbed']

#Iterating through all the files created by layering.py script
for method in methods:
    method_data = []
    with open(method + '.csv', 'r') as file:
        reader = csv.reader(file)
        for row in reader:
            # Files with perturbed data will have 4th column
            # the row will have [ n, size of vc, running time, weights perturb percentage ]
            try:
                method_data.append([ int(row[0]), int(row[1]), float(row[2]), float(row[3]) ])
            except:
                method_data.append([ int(row[0]), int(row[1]), float(row[2]) ])
    data.append(method_data)

# It can be seen that 
# data is a 3d matrix with data[odd index] storing data of non-perturbed cases
# and data[even index] storing data of perturbed cases
figure = plt.figure()
figure.canvas.set_window_title('Layering Algorithm Analysis')
for index, method_data in enumerate(data):
    if index % 2 == 1:
        continue
    n = []
    vc = []
    time = []
    for row in method_data:
        n.append(row[0])
        vc.append(row[1])
        time.append(row[2])

    plt.subplot(2, 1, 1)
    plt.grid(True)
    plt.title('Size of VC')
    plt.xlabel('Number of Vertices (n)')
    plt.ylabel('Size of VC')
    plt.plot(n, vc)
    plt.legend(titles)

    plt.subplot(2, 1, 2)
    plt.grid(True)
    plt.title('Running Time')
    plt.xlabel('Number of Vertices (n)')
    plt.ylabel('Running Time')
    plt.plot(n, time)
    plt.legend(titles)

figure = plt.figure()
figure.canvas.set_window_title('Layering Algorithm Analysis')
for index, method_data in enumerate(data):
    n = []
    vc = []
    time = []
    for row in method_data:
        n.append(row[0])
        vc.append(row[1])
        time.append(row[2])
    
    # subplot(3, 2, ..) implies a grid of plots with 3 rows and 2 columns
    # the last parameter is the index of the current plot in the grid
    # the numbering of plots in grid is sequential :
    # 1  2
    # 3  4
    # 5  6
    # the indexing pattern : for index = 0 to 5
    # (index mod 2)*2 + 1 = 1, 3, 5 
    # (index mod 2)*2 + 1 + 1 = 2, 4, 6
    # It can be seen that left column of the grid is for size of vc vs n plots
    # right side is for running time vs n plots

    plt.subplot(3, 2, (index//2)*2 + 1)
    plt.grid(True)
    plt.title(titles[index//2])
    plt.xlabel('Number of Vertices (n)')
    plt.ylabel('Size of VC')
    plt.plot(n, vc)
    plt.legend(subtitles)

    plt.subplot(3, 2, (index//2)*2 + 1 + 1)
    plt.grid(True)
    plt.title(titles[index//2])
    plt.xlabel('Number of Vertices (n)')
    plt.ylabel('Running Time')
    plt.plot(n, time)
    plt.legend(subtitles)

plt.suptitle('Size of VC and Running time')
plt.subplots_adjust(left=0.1,
                    bottom=0.1, 
                    right=0.9, 
                    top=0.9, 
                    wspace=0.4, 
                    hspace=0.4)
plt.show()


figure = plt.figure()
figure.canvas.set_window_title('Layering Algorithm Analysis')
index = 0
# len(titles) is simply the number of cases considered in layering.py
while index < len(titles):
    deviation_vc = []
    deviation_time = []
    perturb_percentage = []
    for subindex, row in enumerate( data[index*2] ):
        # those with weights perturbation > 10% can be considered as outliers
        # there are atmost 2 outliers after execution of layering.py
        if data[2*index+1][subindex][3] >= 10:
            continue
        # Deviation %, here is calculated by absolute difference between non-perturbed and perturbed values divided by non-perturbed value
        deviation_vc.append( abs(row[1] - data[2*index+1][subindex][1])*100 / row[1] )
        deviation_time.append( abs(row[2]- data[2*index+1][subindex][2])*100 / row[2] )
        perturb_percentage.append( data[2*index+1][subindex][3] )
    
    plt.subplot(3, 2, 2*index + 1)
    plt.grid(True)
    plt.title(titles[index])
    plt.xlabel('Weights Perturb %')
    plt.ylabel('Deviation % in size of VC')
    plt.scatter(perturb_percentage, deviation_vc)

    plt.subplot(3, 2, 2*index + 1 + 1)
    plt.grid(True)
    plt.title(titles[index])
    plt.xlabel('Weights Perturb %')
    plt.ylabel('Deviation % in Running Time')
    plt.scatter(perturb_percentage, deviation_time)

    index += 1

plt.suptitle('Percentage deviation of Size and Running time')
plt.subplots_adjust(left=0.1,
                    bottom=0.1, 
                    right=0.9, 
                    top=0.9, 
                    wspace=0.4, 
                    hspace=0.4)
plt.show()



figure = plt.figure()
figure.canvas.set_window_title('Layering vs. Greedy')
n = []
vc_layering = []
vc_greedy = []
vc_deviation = []
time_layering = []
time_greedy = []
time_deviation = []

for row in data[0]:
    n.append( row[0] )
    vc_layering.append( row[1] )
    time_layering.append( row[2] )

with open('greedy.csv', 'r') as file:
    reader = csv.reader(file)
    for row in reader:
        vc_greedy.append( float(row[1]) )
        time_greedy.append( float(row[2]) )

for index in range( len(n) ):
    vc_deviation.append( abs(vc_greedy[index] - vc_layering[index])*100 / vc_layering[index])
    time_deviation.append( abs(time_greedy[index] - time_layering[index])*100 / time_layering[index])

plt.subplot(2, 2, 1)
plt.grid(True)
plt.xlabel('Number of vertices (n)')
plt.ylabel('Size of VC')
plt.plot(n, vc_layering)
plt.plot(n, vc_greedy)
plt.legend(['Layering with Equal Non-perturbed', 'Greedy'])

plt.subplot(2, 2, 3)
plt.grid(True)
plt.xlabel('Number of vertices (n)')
plt.ylabel('Running Time')
plt.plot(n, time_layering)
plt.plot(n, time_greedy)
plt.legend(['Layering with Equal Non-perturbed', 'Greedy'])

plt.subplot(2, 2, 2)
plt.grid(True)
plt.xlabel('Number of vertices (n)')
plt.ylabel('Deviation % in Size of VC')
plt.scatter(n, vc_deviation)

plt.subplot(2, 2, 4)
plt.grid(True)
plt.xlabel('Number of vertices (n)')
plt.ylabel('Deviation % in Running Time')
plt.scatter(n, time_deviation)


plt.suptitle('Comparison between Layering and Greedy')
plt.subplots_adjust(left=0.1,
                    bottom=0.1, 
                    right=0.9, 
                    top=0.9, 
                    wspace=0.4, 
                    hspace=0.4)
plt.show()